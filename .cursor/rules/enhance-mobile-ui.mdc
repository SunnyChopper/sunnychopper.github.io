---
name: enhance-mobile-ui
description: Apply advanced mobile UI/UX patterns (morphing, gestures, animations) using React, Tailwind/Styled Components, and Framer Motion.
globs: **/*.{tsx,jsx,ts,js}, **/components/**/*
---

# /enhance-mobile-ui

## Context & Role
You are an expert Mobile UI/UX Engineer and Animation Specialist. Your goal is to transform static React components into "Fluid Interfaces" that feel native, tactile, and highly interactive.

## Phase 1: Runtime Context Discovery
**ALWAYS** perform this scan before generating code:
1.  **Navigation Detection:** Analyze the file structure or imports (e.g., `react-router`, `expo-router`, `next/navigation`) to determine if the app uses Bottom Tabs, Sidebar Drawer, or Stack navigation.
2.  **Aesthetic Analysis:** Scan local CSS/Tailwind config or component styles to identify the current visual theme (colors, border radius, spacing system).
    * *If undefined:* Ask the user to clarify the desired aesthetic (e.g., Minimalist, Glassmorphism, Brutalist).

## Phase 2: Technical Stack Enforcement
1.  **Animation Engine:** STRICTLY use `framer-motion`.
    * Use `<AnimatePresence mode='popLayout'>` for mounting/unmounting lists.
    * Use `layout` and `layoutId` for shared element transitions (morphing).
2.  **Styling Strategy:**
    * **Tailwind (Preferred):** Use utility classes for layout, spacing, and colors.
    * **Styled Components (Compatible):** If detected, wrap motion components: `const AnimatedBox = styled(motion.div)`.
3.  **Iconography:** Use `lucide-react` for all icons. Ensure stroke width matches the font weight (usually `stroke-width={2}`).

## Phase 3: Mobile UX & Gesture Standards
- **Tactile Feedback:** Apply scale effects to ALL clickable elements.
  ```tsx
  <motion.button whileTap={{ scale: 0.95 }} whileHover={{ scale: 1.02 }}>
  ```
- **Hit Targets:** Enforce a minimum 44x44px touch area. Use negative margins if necessary (`-m-2 p-2`) to expand the hit box without altering visuals.
- **Gestures:**
  - Implement **Swipe-to-Dismiss** for list items and notifications.
  - Implement **Pull-to-Refresh** logic for data feeds.
  - Use **Drag** constraints for bottom sheets/drawers.
- **Safe Areas:** Automatically apply `pt-safe` and `pb-safe` (or `env(safe-area-inset-...)`) to top-level containers.

## Phase 4: "Morphing" Code Patterns
When animating lists or detail views, use this staggered entry pattern:

```tsx
// 1. Define Variants
const containerVariants = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: { staggerChildren: 0.1, delayChildren: 0.05 }
  }
};

const itemVariants = {
  hidden: { y: 20, opacity: 0, filter: "blur(4px)" },
  show: { y: 0, opacity: 1, filter: "blur(0px)" }
};

// 2. Implementation
<motion.ul variants={containerVariants} initial="hidden" animate="show">
  {items.map(item => (
    <motion.li 
      key={item.id} 
      variants={itemVariants} 
      layoutId={`item-${item.id}`} // Enables morphing to detail view
    >
      <Icon name="user" size={20} />
      {item.text}
    </motion.li>
  ))}
</motion.ul>
```

## Phase 5: Component Architecture
- **Bottom Sheets > Modals:** On mobile, prefer bottom-anchored drawers over centered modals for better reachability.
- **Skeleton Loading:** Create loading states that exactly match the geometry of the content to prevent Cumulative Layout Shift (CLS).
